\hypertarget{syn_8c}{}\section{/home/plizar/\+Documents/\+M\+I\+P\+S/\+M\+I\+P\+S/src/syn.c File Reference}
\label{syn_8c}\index{/home/plizar/\+Documents/\+M\+I\+P\+S/\+M\+I\+P\+S/src/syn.\+c@{/home/plizar/\+Documents/\+M\+I\+P\+S/\+M\+I\+P\+S/src/syn.\+c}}
{\ttfamily \#include $<$stdlib.\+h$>$}\\*
{\ttfamily \#include $<$stdio.\+h$>$}\\*
{\ttfamily \#include $<$string.\+h$>$}\\*
{\ttfamily \#include $<$ctype.\+h$>$}\\*
{\ttfamily \#include $<$strings.\+h$>$}\\*
{\ttfamily \#include $<$global.\+h$>$}\\*
{\ttfamily \#include $<$notify.\+h$>$}\\*
{\ttfamily \#include $<$syn.\+h$>$}\\*
{\ttfamily \#include $<$functions.\+h$>$}\\*
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{syn_8c_a705e027df0cad1d5146940bae2972e24}{instruction\+Set} (inst $\ast$tab)
\begin{DoxyCompactList}\small\item\em A table with all instruction set information is loaded. The structure of this information is described in \char`\"{}inst\char`\"{} type definition. \end{DoxyCompactList}\item 
inst \hyperlink{syn_8c_a7931d3fefc771980dc83f2a389066362}{make\+Inst} (char $\ast$name, char $\ast$op, char $\ast$type, char $\ast$operand, char $\ast$special)
\begin{DoxyCompactList}\small\item\em Routine to make fastly a instruction using string parameters. \end{DoxyCompactList}\item 
unsigned int \hyperlink{syn_8c_abffbb53b0ca30cd7442ec3e22de9edb7}{decode\+Instruction} (chain ch, inst $\ast$inst\+Set)
\begin{DoxyCompactList}\small\item\em In this routine, we decode the instruction using the instruction set. There is 3 types of instructions. We determine the type by analysing the operation symbol. \end{DoxyCompactList}\item 
void \hyperlink{syn_8c_ab9b7b02d49b6abed639d86a1c49bbdb9}{decode\+Directive} (chain ch, char $\ast$tab)
\begin{DoxyCompactList}\small\item\em this routine decode only seleral directives. All other directives are directly managed by \hyperlink{lex_8c}{lex.\+c} In this routine, we manage this directives \+: \end{DoxyCompactList}\item 
char $\ast$ \hyperlink{syn_8c_a65f21f6cf0d382f7a7e0dcaac1fecebc}{register\+To\+Binary} (char $\ast$input)
\begin{DoxyCompactList}\small\item\em this routine convert a char of a specified register to his binary equivalent. \end{DoxyCompactList}\item 
void \hyperlink{syn_8c_a22ae48c78afba08ac52f2b74b77bd941}{fetch} (chain ch, chain sym\+Tab, chain ch\+Code, int $\ast$section, unsigned int $\ast$addr, inst $\ast$inst\+Set)
\begin{DoxyCompactList}\small\item\em This routine is used to fetch and decode if needed the input intruction. \end{DoxyCompactList}\item 
void \hyperlink{syn_8c_a49ba694a4aa2c5e5bfa8094c2c64b1d2}{add\+Symbol} (char $\ast$value, chain sym\+Tab, int section, unsigned int addr)
\begin{DoxyCompactList}\small\item\em Add the symbol to the table of symbols. Two path for resolution \+: \end{DoxyCompactList}\item 
symbol \hyperlink{syn_8c_a5127bd2b954dffdf0147eea62b0c5a5b}{find\+Symbol} (char $\ast$value, chain sym\+Tab)
\begin{DoxyCompactList}\small\item\em Find a symbol. Usefull when an operand is decoded for instance. \end{DoxyCompactList}\item 
symbol \hyperlink{syn_8c_ada80df87715be5ac8270f069d5665969}{read\+Symbol} (chain sym\+Elem)
\begin{DoxyCompactList}\small\item\em Read a symbol from a chain element. \end{DoxyCompactList}\item 
symbol \hyperlink{syn_8c_a15fe52eb5089154f8993865e1fe23fea}{create\+Symbol} (char $\ast$value, int section, unsigned int addr)
\begin{DoxyCompactList}\small\item\em Create a symbol. \end{DoxyCompactList}\item 
code \hyperlink{syn_8c_af6d7dafd061572a7a527b662bdb94ff0}{create\+Code} (unsigned int line, unsigned int addr, unsigned int value)
\begin{DoxyCompactList}\small\item\em Create a code container. \end{DoxyCompactList}\item 
void \hyperlink{syn_8c_a8d79e520c793ef3eb83ed8ce05bb874b}{add\+Code} (chain ch\+Code, unsigned int line, unsigned int addr, unsigned int value)
\begin{DoxyCompactList}\small\item\em Add the code to the chain. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Function Documentation}
\index{syn.\+c@{syn.\+c}!add\+Code@{add\+Code}}
\index{add\+Code@{add\+Code}!syn.\+c@{syn.\+c}}
\subsubsection[{\texorpdfstring{add\+Code(chain ch\+Code, unsigned int line, unsigned int addr, unsigned int value)}{addCode(chain chCode, unsigned int line, unsigned int addr, unsigned int value)}}]{\setlength{\rightskip}{0pt plus 5cm}void add\+Code (
\begin{DoxyParamCaption}
\item[{chain}]{ch\+Code, }
\item[{unsigned int}]{line, }
\item[{unsigned int}]{addr, }
\item[{unsigned int}]{value}
\end{DoxyParamCaption}
)}\hypertarget{syn_8c_a8d79e520c793ef3eb83ed8ce05bb874b}{}\label{syn_8c_a8d79e520c793ef3eb83ed8ce05bb874b}


Add the code to the chain. 


\begin{DoxyParams}{Parameters}
{\em line} & The line of the code. Can be used to final display. (Is like an ID) \\
\hline
{\em addr} & Mandatory, the address of the code regarding to the section \\
\hline
{\em value} & Unsigned int to store the code \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a code. 
\end{DoxyReturn}


Definition at line 668 of file syn.\+c.

\index{syn.\+c@{syn.\+c}!add\+Symbol@{add\+Symbol}}
\index{add\+Symbol@{add\+Symbol}!syn.\+c@{syn.\+c}}
\subsubsection[{\texorpdfstring{add\+Symbol(char $\ast$value, chain sym\+Tab, int section, unsigned int addr)}{addSymbol(char *value, chain symTab, int section, unsigned int addr)}}]{\setlength{\rightskip}{0pt plus 5cm}void add\+Symbol (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{value, }
\item[{chain}]{sym\+Tab, }
\item[{int}]{section, }
\item[{unsigned int}]{addr}
\end{DoxyParamCaption}
)}\hypertarget{syn_8c_a49ba694a4aa2c5e5bfa8094c2c64b1d2}{}\label{syn_8c_a49ba694a4aa2c5e5bfa8094c2c64b1d2}


Add the symbol to the table of symbols. Two path for resolution \+: 


\begin{DoxyParams}{Parameters}
{\em value} & String value of symbol \\
\hline
{\em sym\+Tab} & Table to complete \\
\hline
{\em section} & Section identified \\
\hline
{\em addr} & Address in section \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
nothing
\begin{DoxyItemize}
\item if section is not defined, just add
\item if section defined, add section and addr 
\end{DoxyItemize}
\end{DoxyReturn}


Definition at line 543 of file syn.\+c.

\index{syn.\+c@{syn.\+c}!create\+Code@{create\+Code}}
\index{create\+Code@{create\+Code}!syn.\+c@{syn.\+c}}
\subsubsection[{\texorpdfstring{create\+Code(unsigned int line, unsigned int addr, unsigned int value)}{createCode(unsigned int line, unsigned int addr, unsigned int value)}}]{\setlength{\rightskip}{0pt plus 5cm}code create\+Code (
\begin{DoxyParamCaption}
\item[{unsigned int}]{line, }
\item[{unsigned int}]{addr, }
\item[{unsigned int}]{value}
\end{DoxyParamCaption}
)}\hypertarget{syn_8c_af6d7dafd061572a7a527b662bdb94ff0}{}\label{syn_8c_af6d7dafd061572a7a527b662bdb94ff0}


Create a code container. 


\begin{DoxyParams}{Parameters}
{\em line} & The line of the code. Can be used to final display. (Is like an ID) \\
\hline
{\em addr} & Mandatory, the address of the code regarding to the section \\
\hline
{\em value} & Unsigned int to store the code \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a code. 
\end{DoxyReturn}


Definition at line 650 of file syn.\+c.

\index{syn.\+c@{syn.\+c}!create\+Symbol@{create\+Symbol}}
\index{create\+Symbol@{create\+Symbol}!syn.\+c@{syn.\+c}}
\subsubsection[{\texorpdfstring{create\+Symbol(char $\ast$value, int section, unsigned int addr)}{createSymbol(char *value, int section, unsigned int addr)}}]{\setlength{\rightskip}{0pt plus 5cm}symbol create\+Symbol (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{value, }
\item[{int}]{section, }
\item[{unsigned int}]{addr}
\end{DoxyParamCaption}
)}\hypertarget{syn_8c_a15fe52eb5089154f8993865e1fe23fea}{}\label{syn_8c_a15fe52eb5089154f8993865e1fe23fea}


Create a symbol. 


\begin{DoxyParams}{Parameters}
{\em section} & Symbol section, if U\+N\+D\+E\+F\+I\+N\+ED, symbol not defined. \\
\hline
{\em addr} & If section defined, this value have a meaning. \\
\hline
{\em value} & Symbol value \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
symbol. 
\end{DoxyReturn}


Definition at line 631 of file syn.\+c.

\index{syn.\+c@{syn.\+c}!decode\+Directive@{decode\+Directive}}
\index{decode\+Directive@{decode\+Directive}!syn.\+c@{syn.\+c}}
\subsubsection[{\texorpdfstring{decode\+Directive(chain ch, char $\ast$tab)}{decodeDirective(chain ch, char *tab)}}]{\setlength{\rightskip}{0pt plus 5cm}void decode\+Directive (
\begin{DoxyParamCaption}
\item[{chain}]{ch, }
\item[{char $\ast$}]{tab}
\end{DoxyParamCaption}
)}\hypertarget{syn_8c_ab9b7b02d49b6abed639d86a1c49bbdb9}{}\label{syn_8c_ab9b7b02d49b6abed639d86a1c49bbdb9}


this routine decode only seleral directives. All other directives are directly managed by \hyperlink{lex_8c}{lex.\+c} In this routine, we manage this directives \+: 


\begin{DoxyParams}{Parameters}
{\em ch} & The chain to analyse. \\
\hline
{\em tab} & a char array used to load code byte by byte. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
nothing.
\begin{DoxyItemize}
\item .word w1, ... wn \+: put n word in contiguous way.
\item .byte b1, ... bn \+: put n bytes in contiguous way.
\item .asciiz s1, ... sn \+: put n string in contiguous way.
\item .space n \+: put n bytes initalized to 0. 
\end{DoxyItemize}
\end{DoxyReturn}


Definition at line 364 of file syn.\+c.

\index{syn.\+c@{syn.\+c}!decode\+Instruction@{decode\+Instruction}}
\index{decode\+Instruction@{decode\+Instruction}!syn.\+c@{syn.\+c}}
\subsubsection[{\texorpdfstring{decode\+Instruction(chain ch, inst $\ast$inst\+Set)}{decodeInstruction(chain ch, inst *instSet)}}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int decode\+Instruction (
\begin{DoxyParamCaption}
\item[{chain}]{ch, }
\item[{inst $\ast$}]{inst\+Set}
\end{DoxyParamCaption}
)}\hypertarget{syn_8c_abffbb53b0ca30cd7442ec3e22de9edb7}{}\label{syn_8c_abffbb53b0ca30cd7442ec3e22de9edb7}


In this routine, we decode the instruction using the instruction set. There is 3 types of instructions. We determine the type by analysing the operation symbol. 

\begin{DoxyReturn}{Returns}
A int that contain the instruction. 
\end{DoxyReturn}


Definition at line 155 of file syn.\+c.

\index{syn.\+c@{syn.\+c}!fetch@{fetch}}
\index{fetch@{fetch}!syn.\+c@{syn.\+c}}
\subsubsection[{\texorpdfstring{fetch(chain ch, chain sym\+Tab, chain ch\+Code, int $\ast$section, unsigned int $\ast$addr, inst $\ast$inst\+Set)}{fetch(chain ch, chain symTab, chain chCode, int *section, unsigned int *addr, inst *instSet)}}]{\setlength{\rightskip}{0pt plus 5cm}void fetch (
\begin{DoxyParamCaption}
\item[{chain}]{ch, }
\item[{chain}]{sym\+Tab, }
\item[{chain}]{ch\+Code, }
\item[{int $\ast$}]{section, }
\item[{unsigned int $\ast$}]{addr, }
\item[{inst $\ast$}]{inst\+Set}
\end{DoxyParamCaption}
)}\hypertarget{syn_8c_a22ae48c78afba08ac52f2b74b77bd941}{}\label{syn_8c_a22ae48c78afba08ac52f2b74b77bd941}


This routine is used to fetch and decode if needed the input intruction. 


\begin{DoxyParams}{Parameters}
{\em ch} & Chain built by \hyperlink{lex_8c}{lex.\+c} \\
\hline
{\em sym\+Tab} & Last element of the symbol chain. \\
\hline
{\em code} & The code chain. In fact, this is return of this routine. \\
\hline
{\em section} & Pointer on the section, if N\+U\+LL, no section defined yet. \\
\hline
{\em addr} & Address in this section, if N\+U\+LL, no section defined yet. \\
\hline
{\em inst\+Set} & Instruction Set if instruction decode is needed. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
nothing 
\end{DoxyReturn}


Definition at line 459 of file syn.\+c.

\index{syn.\+c@{syn.\+c}!find\+Symbol@{find\+Symbol}}
\index{find\+Symbol@{find\+Symbol}!syn.\+c@{syn.\+c}}
\subsubsection[{\texorpdfstring{find\+Symbol(char $\ast$value, chain sym\+Tab)}{findSymbol(char *value, chain symTab)}}]{\setlength{\rightskip}{0pt plus 5cm}symbol find\+Symbol (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{value, }
\item[{chain}]{sym\+Tab}
\end{DoxyParamCaption}
)}\hypertarget{syn_8c_a5127bd2b954dffdf0147eea62b0c5a5b}{}\label{syn_8c_a5127bd2b954dffdf0147eea62b0c5a5b}


Find a symbol. Usefull when an operand is decoded for instance. 


\begin{DoxyParams}{Parameters}
{\em value} & String value of symbol \\
\hline
{\em sym\+Tab} & Table of symbols \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the symbol if found, N\+U\+LL if not. 
\end{DoxyReturn}


Definition at line 596 of file syn.\+c.

\index{syn.\+c@{syn.\+c}!instruction\+Set@{instruction\+Set}}
\index{instruction\+Set@{instruction\+Set}!syn.\+c@{syn.\+c}}
\subsubsection[{\texorpdfstring{instruction\+Set(inst $\ast$tab)}{instructionSet(inst *tab)}}]{\setlength{\rightskip}{0pt plus 5cm}void instruction\+Set (
\begin{DoxyParamCaption}
\item[{inst $\ast$}]{tab}
\end{DoxyParamCaption}
)}\hypertarget{syn_8c_a705e027df0cad1d5146940bae2972e24}{}\label{syn_8c_a705e027df0cad1d5146940bae2972e24}


A table with all instruction set information is loaded. The structure of this information is described in \char`\"{}inst\char`\"{} type definition. 

\begin{DoxyReturn}{Returns}
A tab of the desired instruction set. 
\end{DoxyReturn}


Definition at line 33 of file syn.\+c.

\index{syn.\+c@{syn.\+c}!make\+Inst@{make\+Inst}}
\index{make\+Inst@{make\+Inst}!syn.\+c@{syn.\+c}}
\subsubsection[{\texorpdfstring{make\+Inst(char $\ast$name, char $\ast$op, char $\ast$type, char $\ast$operand, char $\ast$special)}{makeInst(char *name, char *op, char *type, char *operand, char *special)}}]{\setlength{\rightskip}{0pt plus 5cm}inst make\+Inst (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{name, }
\item[{char $\ast$}]{op, }
\item[{char $\ast$}]{type, }
\item[{char $\ast$}]{operand, }
\item[{char $\ast$}]{special}
\end{DoxyParamCaption}
)}\hypertarget{syn_8c_a7931d3fefc771980dc83f2a389066362}{}\label{syn_8c_a7931d3fefc771980dc83f2a389066362}


Routine to make fastly a instruction using string parameters. 


\begin{DoxyParams}{Parameters}
{\em name} & Name of instruction, \char`\"{}\+A\+D\+D\char`\"{} \\
\hline
{\em op} & Binary translation, \char`\"{}10000\char`\"{} \\
\hline
{\em type} & From enum (see header) R =$>$ 0, ... \\
\hline
{\em operand} & Define which operands are defined. For example, 0110 =$>$ Only rt and rd can be defined in assembly source code. \\
\hline
{\em special} & Define automatically some operands. For example, sa=00000 in case of A\+DD. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A completed structure Inst, ready to be added to the instruction set chain. 
\end{DoxyReturn}


Definition at line 125 of file syn.\+c.

\index{syn.\+c@{syn.\+c}!read\+Symbol@{read\+Symbol}}
\index{read\+Symbol@{read\+Symbol}!syn.\+c@{syn.\+c}}
\subsubsection[{\texorpdfstring{read\+Symbol(chain sym\+Elem)}{readSymbol(chain symElem)}}]{\setlength{\rightskip}{0pt plus 5cm}symbol read\+Symbol (
\begin{DoxyParamCaption}
\item[{chain}]{sym\+Elem}
\end{DoxyParamCaption}
)}\hypertarget{syn_8c_ada80df87715be5ac8270f069d5665969}{}\label{syn_8c_ada80df87715be5ac8270f069d5665969}


Read a symbol from a chain element. 


\begin{DoxyParams}{Parameters}
{\em sym\+Tab} & Element of sym\+Tab. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
readed symbol, N\+U\+LL if nothing to read. 
\end{DoxyReturn}


Definition at line 616 of file syn.\+c.

\index{syn.\+c@{syn.\+c}!register\+To\+Binary@{register\+To\+Binary}}
\index{register\+To\+Binary@{register\+To\+Binary}!syn.\+c@{syn.\+c}}
\subsubsection[{\texorpdfstring{register\+To\+Binary(char $\ast$input)}{registerToBinary(char *input)}}]{\setlength{\rightskip}{0pt plus 5cm}char$\ast$ register\+To\+Binary (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{input}
\end{DoxyParamCaption}
)}\hypertarget{syn_8c_a65f21f6cf0d382f7a7e0dcaac1fecebc}{}\label{syn_8c_a65f21f6cf0d382f7a7e0dcaac1fecebc}


this routine convert a char of a specified register to his binary equivalent. 

\begin{DoxyReturn}{Returns}
A translated string of register name 
\end{DoxyReturn}


Definition at line 428 of file syn.\+c.

